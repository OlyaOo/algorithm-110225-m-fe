/**
 * Разделяет массив на две половины.
 * @param {Array} arr - Входной массив для разделения.
 * @returns {Array} - Массив, содержащий два подмассива [left, right].
 */
export function splitArray(arr) {
    // Алгоритмические шаги:
    // 1. Вычислить средний индекс массива.
    // 2. Создать левую половину, срезав от начала до середины.
    // 3. Создать правую половину, срезав от середины до конца.
    // 4. Вернуть массив, содержащий обе половины.
}

/**
 * Рекурсивно разделяет массив на вложенные подмассивы.
 * @param {Array} arr - Входной массив для разделения.
 * @returns {Array} - Вложенная структура массива подмассивов.
 */
export function recursiveSplit(arr) {
    // Алгоритмические шаги:
    // 1. Если длина массива равна 1 или меньше, вернуть массив.
    // 2. Вычислить средний индекс массива.
    // 3. Рекурсивно разделить левую половину (от начала до середины).
    // 4. Рекурсивно разделить правую половину (от середины до конца).
    // 5. Вернуть массив, содержащий результаты обоих рекурсивных разделений.
}

/**
 * Объединяет два отсортированных массива в один отсортированный массив.
 * @param {Array} left - Левый отсортированный массив.
 * @param {Array} right - Правый отсортированный массив.
 * @returns {Array} - Новый отсортированный массив, содержащий все элементы из обоих входных массивов.
 */
export function merge(left, right) {
    // Алгоритмические шаги:
    // 1. Инициализировать пустой результирующий массив.
    // 2. Инициализировать индексы для левого и правого массивов, начиная с 0.
    // 3. Пока оба индекса находятся в пределах своих массивов:
    //    a. Сравнить элементы на текущих индексах левого и правого массивов.
    //    b. Добавить меньший элемент в результирующий массив и увеличить соответствующий индекс.
    // 4. Добавить оставшиеся элементы из левого массива в результат.
    // 5. Добавить оставшиеся элементы из правого массива в результат.
    // 6. Вернуть результирующий массив.
}

/**
 * Сортирует массив с использованием алгоритма сортировки слиянием.
 * @param {Array} arr - Входной массив для сортировки.
 * @returns {Array} - Новый отсортированный массив.
 */
export function mergeSort(arr) {
    // Алгоритмические шаги:
    // 1. Проверить, если длина массива равна 1 или меньше; если да, вернуть массив, так как он уже отсортирован.
    // 2. Вычислить средний индекс массива.
    // 3. Разделить массив на левую и правую половины.
    // 4. Рекурсивно применить mergeSort к левой половине.
    // 5. Рекурсивно применить mergeSort к правой половине.
    // 6. Объединить отсортированные левую и правую половины.
    // 7. Вернуть объединенный результат.
}

/**
 * Сортирует массив с использованием сортировки слиянием и вспомогательного буфера.
 * @param {Array} arr - Входной массив для сортировки.
 * @returns {Array} - Отсортированный входной массив.
 */
export function mergeSort2(arr) {
    // Алгоритмические шаги:
    // 1. Создать копию входного массива в качестве вспомогательного буфера.
    // 2. Вызвать mergeSortRecursive с массивом, вспомогательным буфером, начальным индексом (0) и конечным индексом (длина массива).
    // 3. Вернуть отсортированный массив.
}

/**
 * Рекурсивно сортирует подмассив с использованием вспомогательного буфера.
 * @param {Array} arr - Массив для сортировки.
 * @param {Array} aux - Вспомогательный буферный массив.
 * @param {number} start - Начальный индекс подмассива.
 * @param {number} end - Конечный индекс подмассива (исключительно).
 */
export function mergeSortRecursive(arr, aux, start, end) {
    // Алгоритмические шаги:
    // 1. Если подмассив имеет 1 или меньше элементов, вернуть (сортировка не требуется).
    // 2. Вычислить средний индекс подмассива.
    // 3. Рекурсивно отсортировать левую половину (от начала до середины).
    // 4. Рекурсивно отсортировать правую половину (от середины до конца).
    // 5. Объединить отсортированные половины в исходный массив с использованием функции mergeAndSort.
}

/**
 * Объединяет два отсортированных подмассива с использованием вспомогательного буфера.
 * @param {Array} arr - Массив для хранения объединенного результата.
 * @param {Array} aux - Вспомогательный буфер, содержащий данные подмассива.
 * @param {number} start - Начальный индекс подмассива.
 * @param {number} mid - Средний индекс, разделяющий два подмассива.
 * @param {number} end - Конечный индекс подмассива (исключительно).
 */
export function mergeAndSort(arr, aux, start, mid, end) {
    // Алгоритмические шаги:
    // 1. Скопировать диапазон подмассива (от start до end) во вспомогательный буфер.
    // 2. Инициализировать индексы: i для левой половины (start), j для правой половины (mid), k для результирующего массива (start).
    // 3. Пока оба индекса i и j находятся в пределах своих половин:
    //    a. Сравнить элементы из вспомогательного буфера на индексах i и j.
    //    b. Поместить меньший элемент в исходный массив на индекс k и увеличить i или j и k.
    // 4. Скопировать оставшиеся элементы из левой половины (если есть) в исходный массив.
    // 5. (Элементы правой половины уже находятся на своих местах, поэтому дополнительное копирование не требуется.)
}

/**
 * Напишите функцию mergeAndFilter, которая принимает массив, функцию фильтрации и флаг для сортировки
 * по убыванию. Функция должна сначала отфильтровать массив, оставив только те элементы,
 * которые удовлетворяют условию фильтрации. Затем отфильтрованный массив должен быть отсортирован с использованием
 * алгоритма сортировки слиянием. Если флаг desc установлен в true, массив должен быть
 * отсортирован по убыванию, иначе — по возрастанию.
*/

/**
 * Фильтрует массив и сортирует отфильтрованные элементы с использованием алгоритма сортировки слиянием.
 * @param {Array} array - Входной массив для фильтрации и сортировки.
 * @param {Function} filter - Функция фильтрации элементов.
 * @param {boolean} [desc=false] - Флаг для сортировки по убыванию.
 * @returns {Array} - Новый отсортированный массив, содержащий только отфильтрованные элементы.
 */
export function mergeAndFilter(array, filter, desc = false) {
    // Алгоритмические шаги:
    // 1. Инициализировать пустой массив для хранения отфильтрованных элементов.
    // 2. Пройти по каждому элементу входного массива.
    // 3. Если элемент удовлетворяет условию фильтра, добавить его в новый массив.
    // 4. Инициализировать временный массив для использования в сортировке слиянием.
    // 5. Вызвать функцию merge для сортировки отфильтрованного массива.
    // 6. Вернуть отсортированный массив.
}