/**
 * Разделяет массив на две половины.
 * @param {Array} arr - Входной массив для разделения.
 * @returns {Array} - Массив, содержащий два подмассива [left, right].
 */
export function splitArray(arr) {
    if (!arr.length) {
        return [];
        //throw new Error("Массив пустой или неопределен");
    }
    // Алгоритмические шаги:
    // 1. Вычислить средний индекс массива.
    const midIndex = Math.floor(arr.length/2); // 5/2 => 2 
    // 2. Создать левую половину, срезав от начала до середины.
    const leftArr = arr.slice(0, midIndex); //
    // 3. Создать правую половину, срезав от середины до конца.
    const rightArr = arr.slice(midIndex, arr.length);
    // 4. Вернуть массив, содержащий обе половины.
    return [leftArr, rightArr];
}

/**
 * Рекурсивно разделяет массив на вложенные подмассивы.
 * @param {Array} arr - Входной массив для разделения.
 * @returns {Array} - Вложенная структура массива подмассивов.
 */
export function recursiveSplit(arr) { // [1, 2, 3, 4, 5, 6, 7] // [1, 2, 3]
    // Алгоритмические шаги:
   
    if (!arr.length) {
        return [];
    }
    // 1. Если длина массива равна 1 или меньше, вернуть массив.
    if (arr.length <= 1) {
     return arr;
    }
   
    // 2. Вычислить средний индекс массива.
    const midIndex = Math.floor(arr.length/2); // 4/2 => 2  step 1 mid = 2 
    // 3. Рекурсивно разделить левую половину (от начала до середины).
    const leftArr = recursiveSplit(arr.slice(0, midIndex)); // [1,2,3] => [1] [2,3]
    // 4. Рекурсивно разделить правую половину (от середины до конца).
    const rightArr = recursiveSplit(arr.slice(midIndex)); // [4, 5, 6, 7]
    // 5. Вернуть массив, содержащий результаты обоих рекурсивных разделений.
    return [leftArr, rightArr];
}

/**
 * Объединяет два отсортированных массива в один отсортированный массив.
 * @param {Array} left - Левый отсортированных массив.
 * @param {Array} right - Правый отсортированных массив.
 * @returns {Array} - Новый отсортированный массив, содержащий все элементы из обоих входных массивов.
 */
export function merge(left, right) {
    // Алгоритмические шаги:
    // 1. Инициализировать пустой результирующий массив.
    const arr = [];
    // 2. Инициализировать индексы для левого и правого массивов, начиная с 0.
    let i = 0;
    let j = 0;
    // 3. Пока оба индекса находятся в пределах своих массивов:
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            arr.push(left[i]);
            i++;
        } else {
            arr.push(right[j]);
            j++;
        }
    }

    while (i < left.length) {
        arr.push(left[i]);
        i++;
    }

    while (j < right.length) {
        arr.push(right[j]);
        j++;
    }

    return arr;
    //    a. Сравнить элементы на текущих индексах левого и правого массивов.
    //    b. Добавить меньший элемент в результирующий массив и увеличить соответствующий индекс.
    // 4. Добавить оставшиеся элементы из левого массива в результат.
    // 5. Добавить оставшиеся элементы из правого массива в результат.
    // 6. Вернуть результирующий массив.
}

/**
 * Сортирует массив с использованием алгоритма сортировки слиянием.
 * @param {Array} arr - Входной массив для сортировки.
 * @returns {Array} - Новый отсортированный массив.
 */
export function mergeSort(arr) {
    // Алгоритмические шаги:
    if (!arr.length) {
        //throw new Error("Массив пуст");
        return [];
    }
    // 1. Проверить, если длина массива равна 1 или меньше; если да, вернуть массив, так как он уже отсортирован.
    if (arr.length <=1) {
        return arr;
    }
    const midIndex = Math.floor(arr.length/2);
    const leftArray = mergeSort(arr.slice(0, midIndex));
    const rightArray = mergeSort(arr.slice(midIndex, arr.length));

    return mergeTwoArrays(leftArray, rightArray);
}

function mergeTwoArrays(arrayLeft, arrayRight) {
    const result = [];
    let indexLeft = 0;
    let indexRight = 0;
    while (indexLeft < arrayLeft.length && indexRight < arrayRight.length) {
        if (arrayLeft[indexLeft] < arrayRight[indexRight]) {
            result.push(arrayLeft[indexLeft]);
            indexLeft++;
        } else {
            result.push(arrayRight[indexRight]);
            indexRight++;
        }
    }

    while(indexLeft < arrayLeft.length) {
        result.push(arrayLeft[indexLeft]);
        indexLeft++;
    }

    while (indexRight < arrayRight.length) {
        result.push(arrayRight[indexRight]);
        indexRight++;
    }
    return result;
}

/**
 * Сортирует массив с использованием сортировки слиянием и вспомогательного буфера.
 * @param {Array} arr - Входной массив для сортировки.
 * @returns {Array} - Отсортированный входной массив.
 */
export function mergeSort2(arr) {
    // Алгоритмические шаги:
    // 1. Создать копию входного массива в качестве вспомогательного буфера.
    // 2. Вызвать mergeSortRecursive с массивом, вспомогательным буфером, начальным индексом (0) и конечным индексом (длина массива).
    // 3. Вернуть отсортированный массив.
}

/**
 * Рекурсивно сортирует подмассив с использованием вспомогательного буфера.
 * @param {Array} arr - Массив для сортировки.
 * @param {Array} aux - Вспомогательный буферный массив.
 * @param {number} start - Начальный индекс подмассива.
 * @param {number} end - Конечный индекс подмассива (исключительно).
 */
export function mergeSortRecursive(arr, aux, start, end) {
    // Алгоритмические шаги:
    // 1. Если подмассив имеет 1 или меньше элементов, вернуть (сортировка не требуется).
    // 2. Вычислить средний индекс подмассива.
    // 3. Рекурсивно отсортировать левую половину (от начала до середины).
    // 4. Рекурсивно отсортировать правую половину (от середины до конца).
    // 5. Объединить отсортированные половины в исходный массив с использованием функции mergeAndSort.
}

/**
 * Объединяет два отсортированных подмассива с использованием вспомогательного буфера.
 * @param {Array} arr - Массив для хранения объединенного результата.
 * @param {Array} aux - Вспомогательный буфер, содержащий данные подмассива.
 * @param {number} start - Начальный индекс подмассива.
 * @param {number} mid - Средний индекс, разделяющий два подмассива.
 * @param {number} end - Конечный индекс подмассива (исключительно).
 */
export function mergeAndSort(arr, aux, start, mid, end) {
    // Алгоритмические шаги:
    // 1. Скопировать диапазон подмассива (от start до end) во вспомогательный буфер.
    // 2. Инициализировать индексы: i для левой половины (start), j для правой половины (mid), k для результирующего массива (start).
    // 3. Пока оба индекса i и j находятся в пределах своих половин:
    //    a. Сравнить элементы из вспомогательного буфера на индексах i и j.
    //    b. Поместить меньший элемент в исходный массив на индекс k и увеличить i или j и k.
    // 4. Скопировать оставшиеся элементы из левой половины (если есть) в исходный массив.
    // 5. (Элементы правой половины уже находятся на своих местах, поэтому дополнительное копирование не требуется.)
}

/**
 * Напишите функцию mergeAndFilter, которая принимает массив, функцию фильтрации и флаг для сортировки
 * по убыванию. Функция должна сначала отфильтровать массив, оставив только те элементы,
 * которые удовлетворяют условию фильтрации. Затем отфильтрованный массив должен быть отсортирован с использованием
 * алгоритма сортировки слиянием. Если флаг desc установлен в true, массив должен быть
 * отсортирован по убыванию, иначе — по возрастанию.
*/

/**
 * Фильтрует массив и сортирует отфильтрованные элементы с использованием алгоритма сортировки слиянием.
 * @param {Array} array - Входной массив для фильтрации и сортировки.
 * @param {Function} filter - Функция фильтрации элементов.
 * @param {boolean} [desc=false] - Флаг для сортировки по убыванию.
 * @returns {Array} - Новый отсортированный массив, содержащий только отфильтрованные элементы.
 */
export function mergeAndFilter(array, filter, desc = false) {
    // Алгоритмические шаги:
    // 1. Инициализировать пустой массив для хранения отфильтрованных элементов.
    // 2. Пройти по каждому элементу входного массива.
    // 3. Если элемент удовлетворяет условию фильтра, добавить его в новый массив.
    // 4. Инициализировать временный массив для использования в сортировке слиянием.
    // 5. Вызвать функцию merge для сортировки отфильтрованного массива.
    // 6. Вернуть отсортированный массив.
}

//console.log(splitArray([1, 2, 3, 4]));
//console.log(recursiveSplit([1, 2, 3, 4]));

console.log(merge([1,2,3], [4,5,6]));
console.log(merge([7,8,9], [4,5,6]));

console.log("result  = " + mergeSort([3, 2, 5, 12, 8, 10]));