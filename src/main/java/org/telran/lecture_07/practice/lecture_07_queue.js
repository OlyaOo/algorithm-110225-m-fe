/**
 * Класс, представляющий структуру данных очередь, реализованную на основе массива.
 * Элементы добавляются в конец (enqueue) и удаляются из начала (dequeue).
 */
class ArrayQueue {
    /**
     * Создает экземпляр ArrayQueue.
     * Инициализирует пустой массив для хранения элементов очереди.
     */
    constructor() {
        // TODO: Инициализировать пустой массив для хранения элементов очереди
    }

    /**
     * Добавляет элемент в конец очереди.
     * @param {*} element - Элемент, который нужно добавить в очередь.
     */
    enqueue(element) {
        // TODO: Добавить элемент в конец массива
        // TODO: Вывести сообщение в консоль, что элемент добавлен, например: "Добавлен в очередь: <element>"
    }

    /**
     * Удаляет и возвращает элемент из начала очереди.
     * @returns {*} Удаленный элемент из очереди или null, если очередь пуста.
     */
    dequeue() {
        // TODO: Проверить, пуста ли очередь; если да, вывести в консоль "Очередь пуста! Невозможно выполнить dequeue()" и вернуть null
        // TODO: Удалить и сохранить первый элемент массива (учтите, что array.shift() имеет сложность O(n))
        // TODO: Вывести сообщение в консоль, что элемент удален, например: "Удален из очереди: <element>"
        // TODO: Вернуть удаленный элемент
    }

    /**
     * Возвращает первый элемент очереди без его удаления.
     * @returns {*} Первый элемент очереди или null, если очередь пуста.
     */
    front() {
        // TODO: Проверить, пуста ли очередь; если да, вернуть null
        // TODO: Вернуть первый элемент массива без его удаления
    }

    /**
     * Возвращает последний элемент очереди без его удаления.
     * @returns {*} Последний элемент очереди или null, если очередь пуста.
     */
    rear() {
        // TODO: Проверить, пуста ли очередь; если да, вернуть null
        // TODO: Вернуть последний элемент массива без его удаления
    }

    /**
     * Проверяет, пуста ли очередь.
     * @returns {boolean} True, если очередь пуста, иначе false.
     */
    isEmpty() {
        // TODO: Вернуть true, если длина массива равна 0, иначе false
    }

    /**
     * Возвращает количество элементов в очереди.
     * @returns {number} Количество элементов в очереди.
     */
    size() {
        // TODO: Вернуть длину массива
    }

    /**
     * Очищает очередь, удаляя все элементы.
     */
    clear() {
        // TODO: Очистить массив, установив его в пустой массив
        // TODO: Вывести сообщение в консоль: "Очередь очищена"
    }

    /**
     * Выводит содержимое очереди в консоль.
     */
    display() {
        // TODO: Проверить, пуста ли очередь; если да, вывести в консоль "Очередь пуста" и завершить выполнение
        // TODO: Вывести в консоль сообщение "Содержимое очереди (начало -> конец):"
        // TODO: Вывести элементы массива, соединенные строкой " <- "
    }

    /**
     * Выполняет указанную функцию для каждого элемента очереди.
     * @param {function} callback - Функция, которая будет вызвана для каждого элемента. Принимает элемент, индекс и массив.
     */
    forEach(callback) {
        // TODO: Пройтись по всем элементам массива
        // TODO: Вызвать callback для каждого элемента, передав элемент, его индекс и массив
    }
}

/**
 * Класс, представляющий узел односвязного списка.
 */
class Node {
    /**
     * Создает узел с указанными данными.
     * @param {*} data - Данные, которые будет содержать узел.
     */
    constructor(data) {
        // TODO: Установить данные узла (data)
        // TODO: Установить указатель на следующий узел (next) как null
    }
}

/**
 * Класс, представляющий структуру данных очередь, реализованную на основе односвязного списка.
 * Элементы добавляются в конец (enqueue) и удаляются из начала (dequeue).
 */
class LinkedListQueue {
    /**
     * Создает экземпляр LinkedListQueue.
     * @param {number} [maxSize=Infinity] - Максимально допустимый размер очереди.
     */
    constructor(maxSize = Infinity) {
        // TODO: Инициализировать начало очереди (head) как null
        // TODO: Инициализировать конец очереди (tail) как null
        // TODO: Инициализировать текущий размер (size) как 0
        // TODO: Установить максимальный размер очереди (maxSize) из параметра
    }

    /**
     * Добавляет элемент в конец очереди.
     * @param {*} data - Элемент, который нужно добавить в очередь.
     * @returns {boolean} True, если элемент успешно добавлен, иначе false (если очередь переполнена).
     */
    enqueue(data) {
        // TODO: Проверить, достигнут ли максимальный размер очереди; если да, вывести в консоль "Очередь переполнена" и вернуть false
        // TODO: Создать новый узел с переданным значением data (используйте класс Node)
        // TODO: Если очередь не пуста (tail существует), установить next текущего tail на новый узел
        // TODO: Если очередь пуста (head не существует), установить head на новый узел
        // TODO: Установить tail на новый узел
        // TODO: Увеличить размер очереди (size) на 1
        // TODO: Вывести сообщение в консоль, что элемент добавлен, например: "Добавлен: <data>"
        // TODO: Вернуть true
    }

    /**
     * Удаляет и возвращает элемент из начала очереди.
     * @returns {*} Удаленный элемент или null, если очередь пуста.
     */
    dequeue() {
        // TODO: Проверить, пуста ли очередь; если да, вывести в консоль "Очередь пуста" и вернуть null
        // TODO: Сохранить данные (data) из узла head
        // TODO: Переместить head на следующий узел (head.next)
        // TODO: Уменьшить размер очереди (size) на 1
        // TODO: Если очередь стала пустой (size === 0), установить tail в null
        // TODO: Вывести сообщение в консоль, что элемент удален, например: "Удален: <data>"
        // TODO: Вернуть сохраненные данные
    }

    /**
     * Проверяет, пуста ли очередь.
     * @returns {boolean} True, если очередь пуста, иначе false.
     */
    isEmpty() {
        // TODO: Вернуть true, если head равен null, иначе false
    }

    /**
     * Возвращает текущий размер очереди.
     * @returns {number} Количество элементов в очереди.
     */
    getSize() {
        // TODO: Вернуть текущий размер очереди (size)
    }

    /**
     * Очищает очередь, удаляя все элементы.
     */
    clear() {
        // TODO: Установить head в null
        // TODO: Установить tail в null
        // TODO: Установить size в 0
        // TODO: Вывести сообщение в консоль: "Очередь очищена"
    }

    /**
     * Выполняет указанную функцию для каждого элемента очереди.
     * @param {function} callback - Функция, которая будет вызвана для каждого элемента. Принимает данные элемента и индекс.
     */
    forEach(callback) {
        // TODO: Начать с узла head
        // TODO: Пройтись по всем узлам списка, пока текущий узел существует
        // TODO: Для каждого узла вызвать callback, передав данные узла (data) и текущий индекс
        // TODO: Перейти к следующему узлу и увеличить индекс
    }
}

/**
 * Класс RateLimitedQueue - очередь с ограничением скорости выполнения запросов
 * 
 * Эта структура данных позволяет контролировать частоту выполнения HTTP-запросов,
 * что особенно важно при работе с API, имеющими ограничения на количество запросов в единицу времени.
 * 
 * Принцип работы:
 * - Все запросы добавляются в очередь
 * - Запросы выполняются последовательно с заданной задержкой
 * - Каждый запрос возвращает Promise, который разрешается при получении ответа
 * 
 * Основные преимущества:
 * - Предотвращение превышения лимитов API
 * - Автоматическая обработка очереди запросов
 * - Поддержка асинхронной работы через Promise
 */
class RateLimitedQueue {
  /**
   * Создает новую очередь с ограничением скорости
   * @param {number} rateLimitDelay - Задержка между запросами в миллисекундах
   */
  constructor(rateLimitDelay) {
    // TODO: Инициализировать массив для хранения запросов (queue)
    
    // TODO: Инициализировать флаг isProcessing (boolean) для отслеживания состояния обработки
    
    // TODO: Сохранить rateLimitDelay как свойство класса
  }

  /**
   * Добавляет запрос в очередь
   * 
   * Алгоритм:
   * 1. Добавить запрос в конец очереди
   * 2. Если очередь не обрабатывается, запустить обработку
   * 
   * @param {Object} request - Объект запроса содержащий url, options, resolve, reject
   */
  enqueue(request) {
    // TODO: Добавить request в конец массива queue
    
    // TODO: Проверить, не обрабатывается ли очередь в данный момент
    // TODO: Если isProcessing === false, вызвать метод processQueue()
  }

  /**
   * Обрабатывает очередь запросов последовательно с задержкой
   * 
   * Алгоритм:
   * 1. Проверить, есть ли запросы в очереди
   * 2. Если очередь пуста, остановить обработку
   * 3. Установить флаг обработки
   * 4. Извлечь первый запрос из очереди
   * 5. Выполнить HTTP-запрос
   * 6. Обработать результат (успех/ошибка)
   * 7. Установить таймер для следующего запроса
   * 
   * @async
   * @returns {Promise<void>}
   */
  async processQueue() {
    // TODO: Проверить, есть ли элементы в очереди
    // TODO: Если очередь пуста:
    //   - Установить isProcessing в false
    //   - Выйти из функции (return)
    
    // TODO: Установить isProcessing в true
    
    // TODO: Извлечь первый элемент из очереди 
    
    // TODO: Обернуть выполнение запроса в try-catch блок:
    //   try {
    //     - Выполнить fetch с request.url и request.options
    //     - Преобразовать ответ в JSON
    //     - Вызвать request.resolve(data) для успешного результата
    //   } catch (error) {
    //     - Вызвать request.reject(error) для обработки ошибки
    //   }
    
    // TODO: Установить таймер с задержкой rateLimitDelay для вызова processQueue()
    // Использовать setTimeout(() => this.processQueue(), this.rateLimitDelay)
  }

  /**
   * Отправляет HTTP-запрос через очередь с ограничением скорости
   * 
   * Алгоритм:
   * 1. Создать новый Promise
   * 2. В конструкторе Promise создать объект запроса с url, options, resolve, reject
   * 3. Добавить запрос в очередь через enqueue()
   * 4. Вернуть Promise
   * 
   * @param {string} url - URL для запроса
   * @param {Object} options - Опции для fetch (method, headers, body и т.д.)
   * @returns {Promise} Promise, который разрешается с данными ответа
   */
  async sendRequest(url, options) {
    // TODO: Вернуть новый Promise, который:
    //   - Принимает resolve и reject как параметры
    //   - Создает объект запроса: { url, options, resolve, reject }
    //   - Вызывает this.enqueue() с этим объектом
  }
}

// Пример использования (для демонстрации студентам):
/*
const queue = new RateLimitedQueue(1000); // 1 запрос в секунду

// Добавляем несколько запросов
queue.sendRequest('https://dummyjson.com/test', { method: 'GET' })
  .then(data => console.log('Ответ 1:', data))
  .catch(error => console.error('Ошибка 1:', error));

queue.sendRequest('https://dummyjson.com/ip', { method: 'GET' })
  .then(data => console.log('Ответ 2:', data))
  .catch(error => console.error('Ошибка 2:', error));

queue.sendRequest('https://api.example.com/data3', { method: 'GET' })
  .then(data => console.log('Ответ 3:', data))
  .catch(error => console.error('Ошибка 3:', error));

// Проверка состояния очереди
console.log('Запросов в очереди:', queue.getQueueLength());
console.log('Обрабатывается:', queue.isProcessingQueue());
*/

/**
 * Класс, представляющий систему загрузки файлов с использованием очереди на основе связного списка.
 * Управляет добавлением файлов в очередь, подключением к серверу и обработкой очереди с повторными попытками.
 */
class FileUploader {
    /**
     * Создает экземпляр FileUploader.
     * @param {number} [maxSize=5] - Максимальный размер очереди файлов.
     * @param {number} [retryLimit=3] - Максимальное количество попыток отправки файла.
     */
    constructor(maxSize = 5, retryLimit = 3) {
        // TODO: Инициализировать очередь файлов с использованием LinkedListQueue с указанным maxSize
        // TODO: Установить максимальное количество попыток (retryLimit)
        // TODO: Инициализировать флаг подключения к серверу (isConnected) как false
    }

    /**
     * Добавляет файл в очередь для загрузки.
     * @param {string} fileName - Имя файла для загрузки.
     */
    upload(fileName) {
        // TODO: Создать объект fileTask с полями fileName и attempts (изначально 0)
        // TODO: Добавить fileTask в очередь (используя метод enqueue)
        // TODO: Если файл успешно добавлен, вывести в консоль сообщение, например: "File <fileName> added to queue"
        // TODO: Если подключение к серверу активно (isConnected), вызвать обработку очереди
    }

    /**
     * Устанавливает подключение к серверу и запускает обработку очереди.
     */
    connectToServer() {
        // TODO: Установить флаг isConnected в true
        // TODO: Вызвать метод обработки очереди
    }

    /**
     * Разрывает подключение к серверу.
     */
    disconnect() {
        // TODO: Установить флаг isConnected в false
        // TODO: Вывести в консоль сообщение: "The connection was broken"
    }

    /**
     * Обрабатывает очередь файлов, отправляя их на сервер.
     */
    processQueue() {
        // TODO: Пока очередь не пуста и есть подключение к серверу (isConnected):
        // TODO: Извлечь файл из начала очереди (используя dequeue)
        // TODO: Если количество попыток файла (attempts) достигло retryLimit, вывести ошибку в консоль, например:
        //       "File <fileName> was removed after <retryLimit> attempts", и продолжить цикл
        // TODO: Вызвать метод sendToServer для попытки отправки файла
        // TODO: Если отправка не удалась, увеличить attempts на 1, вывести предупреждение в консоль, например:
        //       "Retry for <fileName>, attempts #<attempts>", и добавить файл обратно в очередь
    }

    /**
     * Отправляет файл на сервер (симуляция).
     * @param {Object} fileTask - Объект задачи с полями fileName и attempts.
     * @returns {boolean} True, если файл успешно отправлен, иначе false.
     */
    sendToServer(fileTask) {
        // TODO: Сымитировать отправку файла, возвращая true с вероятностью > 50% (например, используя Math.random())
        // TODO: Если отправка успешна, вывести в консоль сообщение, например: "The file <fileName> sent successfully"
        // TODO: Если отправка не удалась, вывести в консоль сообщение, например: "The file <fileName> was not sent"
        // TODO: Вернуть результат отправки (true или false)
    }
}