/**
 * Класс CircularBuffer - кольцевой буфер (циклический буфер)
 * 
 * Кольцевой буфер - это структура данных, которая использует массив фиксированного размера
 * как если бы он был соединен в кольцо. Когда массив заполняется, новые данные записываются
 * поверх старых (если разрешена перезапись).
 * 
 * Основные преимущества:
 * - Эффективное использование памяти
 * - Постоянное время выполнения операций O(1)
 * - Возможность работы с потоками данных
 */
class CircularBuffer {
  /**
   * Создает новый кольцевой буфер
   * @param {number} capacity - Максимальная ёмкость буфера (должна быть > 0)
   * @param {boolean} allowOverwrite - Разрешать ли перезапись старых данных при переполнении
   * @throws {Error} Если capacity меньше 1
   */
  constructor(capacity, allowOverwrite = true) {
    // TODO: Проверить, что capacity больше 0, иначе выбросить ошибку
    
    // TODO: Сохранить параметры capacity и allowOverwrite как свойства класса
    
    // TODO: Создать массив размером capacity для хранения данных
    
    // TODO: Инициализировать указатели:
    // - head: указатель на начало буфера (откуда читаем)
    // - tail: указатель на конец буфера (куда записываем)
    // - size: текущее количество элементов в буфере
  }

  /**
   * Проверяет, пуст ли буфер
   * @returns {boolean} true если буфер пуст, false в противном случае
   */
  isEmpty() {
    // TODO: Вернуть true, если size равен 0
  }

  /**
   * Проверяет, полон ли буфер
   * @returns {boolean} true если буфер полон, false в противном случае
   */
  isFull() {
    // TODO: Вернуть true, если size равен capacity
  }

  /**
   * Добавляет элемент в буфер (операция enqueue)
   * 
   * Алгоритм:
   * 1. Если буфер полон и перезапись запрещена - вернуть false
   * 2. Если буфер полон и перезапись разрешена - сдвинуть head и уменьшить size
   * 3. Записать элемент в позицию tail
   * 4. Сдвинуть tail по кольцу: tail = (tail + 1) % capacity
   * 5. Увеличить size
   * 
   * @param {*} item - Элемент для добавления
   * @returns {boolean} true если операция успешна, false если буфер полон и перезапись запрещена
   */
  enqueue(item) {
    // TODO: Проверить, полон ли буфер
    
    // TODO: Если буфер полон:
    //   - Если allowOverwrite === true:
    //     * Сдвинуть head: head = (head + 1) % capacity
    //     * Уменьшить size на 1
    //   - Если allowOverwrite === false:
    //     * Вывести предупреждение в консоль
    //     * Вернуть false
    
    // TODO: Записать item в buffer[tail]
    
    // TODO: Сдвинуть tail по кольцу: tail = (tail + 1) % capacity
    
    // TODO: Увеличить size на 1
    
    // TODO: Вернуть true
  }

  /**
   * Извлекает элемент из буфера (операция dequeue)
   * 
   * Алгоритм:
   * 1. Если буфер пуст - вернуть null
   * 2. Сохранить элемент из позиции head
   * 3. Очистить позицию head (установить в null)
   * 4. Сдвинуть head по кольцу: head = (head + 1) % capacity
   * 5. Уменьшить size
   * 6. Вернуть сохраненный элемент
   * 
   * @returns {*} Извлеченный элемент или null, если буфер пуст
   */
  dequeue() {
    // TODO: Проверить, пуст ли буфер
    // TODO: Если пуст, вывести предупреждение и вернуть null
    
    // TODO: Сохранить элемент из buffer[head] в переменную
    
    // TODO: Очистить buffer[head] (установить в null для избежания утечек памяти)
    
    // TODO: Сдвинуть head по кольцу: head = (head + 1) % capacity
    
    // TODO: Уменьшить size на 1
    
    // TODO: Вернуть сохраненный элемент
  }

  /**
   * Показывает следующий элемент для чтения без его извлечения (операция peek)
   * @returns {*} Следующий элемент или null, если буфер пуст
   */
  peek() {
    // TODO: Если буфер пуст, вернуть null
    
    // TODO: Вернуть элемент из buffer[head] без его удаления
  }

  /**
   * Очищает буфер, сбрасывая все данные и указатели
   */
  clear() {
    // TODO: Создать новый массив размером capacity
    
    // TODO: Сбросить все указатели и счетчики в начальное состояние:
    // - head = 0
    // - tail = 0  
    // - size = 0
  }
}
