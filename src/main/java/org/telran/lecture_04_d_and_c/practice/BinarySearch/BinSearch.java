package org.telran.lecture_04_d_and_c.practice.BinarySearch;
// Алгоритм "Бинарный поиск"
// 1. Начинаем с поиска среднего элемента массива.
// 2. Если средний элемент совпадает с искомым, поиск завершается.
// 3. Если искомый элемент меньше среднего, поиск продолжается в левой половине массива.
// 4. Если искомый элемент больше среднего, поиск продолжается в правой половине массива.
// 5. Шаги 1-4 повторяются до тех пор, пока элемент не будет найден или пока не останется пустой диапазон для поиска.

public class BinSearch {

    /**
     * Реализация классического алгоритма бинарного поиска.
     * <p>
     * Бинарный поиск - это эффективный алгоритм поиска элемента в отсортированном массиве,
     * работающий по принципу "разделяй и властвуй". Вместо последовательного просмотра
     * всех элементов, алгоритм сравнивает искомое значение с элементом в середине массива
     * и отбрасывает половину массива, в которой заведомо не может находиться искомый элемент.
     * <p>
     * Принцип работы алгоритма:
     * 1. Определяем границы поиска - начальный (left) и конечный (right) индексы массива
     * 2. Находим средний элемент массива и сравниваем его с искомым значением
     * 3. Если средний элемент равен искомому - поиск завершен
     * 4. Если средний элемент больше искомого - продолжаем поиск в левой половине массива
     * 5. Если средний элемент меньше искомого - продолжаем поиск в правой половине массива
     * 6. Повторяем шаги 2-5, пока не найдем элемент или пока границы поиска не сойдутся
     * <p>
     * Временная сложность: O(log n), где n - размер массива
     * Пространственная сложность: O(1) для итеративной версии, O(log n) для рекурсивной версии
     * <p>
     * Важно: массив должен быть предварительно отсортирован, иначе алгоритм работать не будет!
     *
     * @param array  отсортированный массив, в котором выполняется поиск
     * @param target искомое значение
     * @param left   начальный индекс области поиска (включительно)
     * @param right  конечный индекс области поиска (включительно)
     * @return индекс найденного элемента или -1, если элемент не найден
     */
    public static int binarySearchRecursive(int[] array, int target, int left, int right) {
        // Базовый случай: если границы сошлись и элемент не найден
        //Пока left меньше или равно right, область поиска не пуста, и мы продолжаем поиск.


        //  Вычислите индекс средней точки mid текущей области поиска.
        //  Чтобы избежать возможного переполнения при больших значениях left и right,


        // Проверяем, является ли средний элемент искомым


        // Если искомый элемент меньше среднего, продолжаем поиск в левой половине


        // Если искомый элемент больше среднего, продолжаем поиск в правой половине

        throw new UnsupportedOperationException("Method binarySearchRecursive is not implemented yet");
    }

    /**
     * Вспомогательный метод для вызова рекурсивного бинарного поиска с начальными параметрами.
     *
     * @param array  отсортированный массив, в котором выполняется поиск
     * @param target искомое значение
     * @return индекс найденного элемента или -1, если элемент не найден
     */
    public static int binarySearch(int[] array, int target) {
        // Проверка на пустой массив
        if (array == null || array.length == 0) {
            return -1;
        }

        // Вызываем рекурсивную версию с начальными границами
        return binarySearchRecursive(array, target, 0, array.length - 1);
    }

    /**
     * Пример использования алгоритма бинарного поиска.
     *
     * @param args аргументы командной строки (не используются)
     */
    public static void main(String[] args) {
        // Создаем отсортированный массив для демонстрации
        int[] sortedArray = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};

        // Элементы для поиска: один присутствует в массиве, другой - нет
        int targetPresent = 11;
        int targetAbsent = 10;

        // Демонстрация рекурсивной версии
        int resultRecursive1 = binarySearch(sortedArray, targetPresent);
        int resultRecursive2 = binarySearch(sortedArray, targetAbsent);

        System.out.println("Рекурсивный бинарный поиск:");
        System.out.println("Искомый элемент " + targetPresent +
                (resultRecursive1 != -1 ? " найден по индексу " + resultRecursive1 : " не найден"));
        System.out.println("Искомый элемент " + targetAbsent +
                (resultRecursive2 != -1 ? " найден по индексу " + resultRecursive2 : " не найден"));
    }
}